
1. 
Input from console, use the newScanner.  

    arr := make([]string, 0)
    scanner := bufio.NewScanner(os.Stdin)   << 
    for {
        fmt.Print("Enter Text: ")
        // Scans a line from Stdin(Console)
        scanner.Scan()        <<  
        // Holds the string that scanned
        text := scanner.Text()    << 
        if len(text) != 0 {
            fmt.Println(text)
            arr = append(arr, text)
        } else {
            break
        }


	bufio.newScanner can also be used to get response from rest apis. 

	res, err := http.Get("http:// ")

	scanner := bufio.NewScanner(res.Body) 

2. 
Use the slice in place of array. 

var xf []int

xf = append(xf, var) 

Orr you can initialize slice with 

var xf []int{1, 2, 3, 4, 5}

Initialize local slice with 

xf := []int{1, 2, 3, 4, 5}

Two dimensional slice 

xf := [][]int{{1, 2}, {3, 4}}

--

Where ever you need the slice of particular given size, you can use make to define slice

bucket := make([]int, 100)

Same for if need to declare map. 


You can use indexing
---------------------------
days := []string{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"}
weekdays := days[0:5]
fmt.Println(weekdays)
// This returns: [Monday Tuesday Wednesday Thursday Friday]

3. 
Define the maps 

xf := map[string]int {
  "TutorialEdge":     2240,
  "MKBHD":            6580350,
  "Fun Fun Function": 171220,
}

Or you can define as 

mymap := make(map[string]int)

mymap["mykey"] = 10
fmt.Println(mymap["mykey"]) // prints out 10

How to iterate: 

for key, value := range mymap {
    fmt.Println(key)
    fmt.Println(value)
}

Retrieve all the keys: 

var keyArray []string

for key := range mymap {
    keyArray = append(keyArray, key)
}

You can delete any key in map 

delete(mymap["mykey"])

4. 
variadic function 

func variadicExample(xf ...interface{}) int {}

interface{} means can pass any type of data. 

5. 
for i, var := range xf {

} 

range can be used to access both index and variables. 


6. use the anonymous function for smaller routines, or routines used for go call or when we have return functions. 

func addOne() func() int {
  var x int
  return func() int {
    x++
    return x + 1
  }
} 

func main() {
	func() {
		fmt.Println("Hello world.")
	}()
}
// The example called anonymous self executing function. 


7. 
use of callback 

func visit(xf []int, callback fun(int)) {
	for _, var := range xf {
		callback(var)
	}
}


8. 
Character variables by default stored in UTF-8 encoding format. 

To convert and print in right format. typecast with rune and then string. 

fmt.Println("%s", string(rune(c)))

In below example 
func main() {
        xf := []int8{'a', 'b', 'c'}

        for _, c := range xf {    << c stored as 97 (utf8 encoded form)
			if c == 'a' {      << I can compare directly with 'a'
                fmt.Println("%u", string(c))   << to print in real chars typecast to string. 
			}
        }
}

9. Composition is all about polymorphism. It defines the way how compose the program to address polymorphism and inheritance. 

It embedding within struct or interface. 

Interface --> 

type Reader interface {
	Read(p []byte (n int), int error)
}

type Writer interface {
	Write(p []byte (n int), int error)
}

type ReaderWrite interface {
	Reader
	Writer
}

strings. Reader(input)  <-- The instance of Reader takes string. 

bufio.Reader(res.Body)   <-- Another case Reader takes the Response body. 


Structure --> 

type Person struct {
	first string
	second string 
	age int 
}

typedef DoubleZero struct {
	person Person
	last string
}

Defined two objects with two different types: 

p1 := DoubleZero {
	person: Person {
		First: "James"
		second: ""
		age: 43
	}
	last: "Bond"
}

p2 := Person { 
	first: "James"
	second: ""
	age: 43
}

// Behavior of function changed with object being passed. 
 
func (p person)checkName() bool {

}

func (d DoubleZero)checkName() string {

}

10. 
We can write polymorphic function whose definition changed with the object being passed. 
It's using interface. 

type square struct {
	side float64
}

type circle struct {
	radius float64
}	

type shape interface {
	area() float64          <<<<   Interface for both circle and square is defined
}

func (s square) area() float64 {      <<<<  Method and s square is the concrete type.  
	return s.side * s.side 
}

func (c circle) area() float64 {	   <<<<<< Method 
	return math.pi * c.radius * c.radius
}

func main() {
	s := square{10}
	c := circle {10}
}


Go language interfaces are different from other languages. In Go language, the interface is a custom type that is used to specify a set of one or more method signatures and the interface is abstract, so you are not allowed to create an instance of the interface. But you are allowed to create a variable of an interface type and this variable can be assigned with a concrete type value that has the methods the interface requires. Or in other words, the interface is a collection of methods as well as it is a custom type.

Interface behavior implemented by the user defined types via method. 

11. 
Interfaces are associated with methods of specific object type. 

If the interface doesn't associate with any methods, then it calls empty interface. It is of unknown type can handle any value. 

interface{}  <---     

Used as function parameters and variadic functions. 

We can't indexing an empty interface. 

12. 
Method set 

Set of method attached to a type. The method set of a type determines the interfaces that the type implements and the methods that can be called using a receiver of that type. 
In a method set each method will have a unique non-blank method name. 

13. 
Pointer receiver 
In simple terms, value receiver makes a copy of the type and pass it to the function. The function stack now holds an equal object but at a different location on memory. Pointer receiver passes the address of a type to the function. The function stack has a reference to the original object.

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (v *Vertex) Scale(f float64) {     <<<< methods with pointer receivers. 
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	v.Scale(10)
	fmt.Println(v.Abs())
}


14. 
Conversion 





15. 
Assertion 





16. 
How we can map a string to a interface 

type Service interface{						<< Service is the interface type 
	SayHi()
}

type MyService struct{}
func (s MyService) SayHi() {
	fmt.Println("Hi")
}

type SecondService struct{}
func (s SecondService) SayHi() {
	fmt.Println("Hello From the 2nd Service")
}

func main() {
	interfaceMap := make(map[string]Service)        << Service mapped here 
	
	interfaceMap["SERVICE-ID-1"] = MyService{}    	<< assigned to different interfaces.  
	interfaceMap["SERVICE-ID-2"] = SecondService{}

	interfaceMap["SERVICE-ID-2"].SayHi()

}




17. 
Concurrency 









18. 
How is the interface different from OOPs of other programming language? 

Interface can also be used as a type, other then loosely coupled methods. 
interface{} --> Generic type. 

This flexibility is not there in other programming language. 



19. 
How the defer works? 
Defer is a language mechanism that puts your function call into a stack. The deferred functions will be executed in reverse order when the host function finishes regardless of whether a panic is called or not. The defer mechanism is very useful for cleaning up resources.






Creating a separate Package? 

1. Some code you can move to a separate package. 
2. The global functions should be start with capital. 
3. have that package in github path. 
4. Import the package in the main package. 
5. Build that package with go install. 
6. call that routine with <package name>.<routine name>. 


Rules 
-----------
1. Don't have the flags as global variables. It's hard to track. 
2. Sometime calling the external package it's better to have the logic defined inside the current package. 
 





 
